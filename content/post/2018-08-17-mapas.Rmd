---
title: Un mapa de Montevideo con leaflet
author: Rafa
date: '2018-07-17'
slug: mapas
categories: [R]
tags:
  - R
  - Viz
---

```{r results='hide', echo = FALSE, message=FALSE, warning=FALSE}

knitr::opts_chunk$set(echo = TRUE, 
                      warning=FALSE,
                      message = FALSE)

```

R tiene abstracciones para trabajar con información geográfica sin entender a fondo los detalles de cómo se hacen las proyecciones cartográficas y qué son los sistemas de coordenadas. 

La API de `StreetView` publica un mapa con bastante información del terreno como calles, ríos y lugares importantes obtenidos a partir de fotos satelitales. Este es el tipo de mapas que suelen usar aplicaciones como Uber o Google Maps. Leaflet facilita el consumo de la API para hacer mapas interactivos generando un widget HTML con controles para moverse y hacer zoom. 


```{r}
library(tidyverse)
library(maptools)
library(leaflet)
library(dplyr)
library(rgdal)
library(shiny)

mvd <- list(lng=-56.164532, lat=-34.901112)

leaflet() %>% 
  setView(lng=mvd$lng, lat=mvd$lat, zoom=12) %>% 
  addTiles(group="Google") 
```

Para hacer este mapa llamamos a `leaflet::leaflet()` sin argumentos, `setView()` para especificar las coordenadas y zoom iniciales y `addTiles()` para dibujar el mapa. Leaflet sigue las convenciones del `tidyverse`, por lo que podemos encadenar las llamadas a las funciones con `%>% `.

Hay otro tipo de mapas que representan algun tipo de entidad geográfica (un país o un barrio) mediante un polígono. La información para construir estos mapas no está disponible en las imágenes satelitales, porque las fronteras entre estas entidades no es visible. En Uruguay, el INE publica _shapefiles_ con la información cartográfica de los departamentos de Uruguay, los barrios de Montevideo, etc.

Los _shapefiles_ se publican con otros archivos que incluyen datos y otros atributos de las formas. `readOGR()` devuelve un objeto `SpatialPolygonsDataFrame`:

```{r}
# leer shapefile (cuidado que incluyen los shpx, dbf, etc.)
states <- readOGR("../../static/shps/barrios/ine_barrios_mvd_nbi85.shp",
                  layer = "ine_barrios_mvd_nbi85", GDAL1_integer64_policy = TRUE)

states@data$barrio <- states@data$NOMBBARR %>% as.character

crswgs84 <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
# proyeccion ine
prj <- CRS("+proj=utm +zone=21 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs")

# asignar proy
proj4string(states) <- prj
# transformar la proyección
st <- spTransform(states, crswgs84)
```


Estos mapas sirven para _choropleths_, visualizaciones que muestran la forma de un área coloreada con alguna variable (población, PIB, etc.):

```{r}
# Choropleth del PIB departamental
```

Los shapefiles tienen las coordenadas de las formas que contienen, por lo que si especificamos la proyección usada podemos superponerlos con los mapas que publica `StreetView`:


```{r setup, message=FALSE, results = "hide"}


crswgs84 <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
# proyeccion ine
prj <- CRS("+proj=utm +zone=21 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs")

# leer shapefile (cuidado que incluyen los shpx, dbf, etc.)
states <- readOGR("../../static/shps/barrios/ine_barrios_mvd_nbi85.shp",
                  layer = "ine_barrios_mvd_nbi85", GDAL1_integer64_policy = TRUE)

states@data$barrio <- states@data$NOMBBARR %>% as.character
# asignar proy
proj4string(states) <- prj
# transformar la proyección
st <- spTransform(states, crswgs84)

```
Un mapa de Montevideo con Leaflet. Las capas pueden ser las de StreetView o la del Shapefile publicado por INE.

```{r}

mvd <- c(-56.164532, -34.901112)
mvd1 <- mvd  + 0.0071
mvd2 <- mvd  - 0.0071


leaflet(st) %>%
  addPolygons(layerId=~NROBARRIO, color = "#444444", weight = 1, smoothFactor = 0.5,
              opacity = 1.0, fillOpacity = 0.5,
              fillColor = ~colorQuantile("YlOrRd", AREA_KM)(AREA_KM),
              highlightOptions = highlightOptions(color = "white", weight = 2,
                                                  bringToFront = TRUE), group="INE") %>%
  addTiles(group="Google") %>%
  addLayersControl(
    overlayGroups = c("INE", "Google"),
    options = layersControlOptions(collapsed = FALSE)
  )
```


El código sigue las convenciones del tidyverse y es similar a un gráfico de `ggplot`, porque organiza el gráfico en capas. 

La diferencia es que los datos de base provienen de un _shapefile_, al que le aplicamos algunas transformaciones. Estas transformaciones especifican las coordenadas de los polígonos del _shapefile_ y permiten superponer este mapa con el de `StreetView`. 

Luego de llamar a `leaflet::leaflet` con el argumento `st`, agregamos una capa de polígonos con `addPolygons`, y especificamos el `fill` de cada polígono con `AREA_KM`.  `AREA_KM` es una columna en un data frame interno que viene con los datos (está en el archivo dbf).

`addTiles` usa la API (por defecto StreetView) para traer el mapa con las features del terreno. El grupo `Google` permite agrupar esta capa del mapa para invocarla después (con los checkboxes).

`addLayerControl` es una capa de controles (dos checkboxes que permiten prender y apagar las otras dos capas del mapa.)
